"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const logging_1 = require("../../../../logging");
const utilities_1 = require("../../utilities");
const BitbucketCloudApiClient_1 = tslib_1.__importDefault(require("./BitbucketCloudApiClient"));
const constants_1 = require("./constants");
class BitbucketCloudContributorAuditProvider {
    async audit(implementationParams) {
        const bitbucketPAT = utilities_1.ParamUtilities.getAsString(implementationParams, "secret");
        const workspace = utilities_1.ParamUtilities.getAsString(implementationParams, "workspace");
        const days = utilities_1.ParamUtilities.getAsNumber(implementationParams, "days");
        const username = utilities_1.ParamUtilities.getAsString(implementationParams, "username");
        const bitbucketApiClient = new BitbucketCloudApiClient_1.default(days, username, bitbucketPAT, workspace);
        const repositories = await bitbucketApiClient.getBitbucketCloudRepositories();
        logging_1.soosLogger.verboseDebug("Fetching commits for each repository");
        const contributors = await this.getBitbucketCloudRepositoryContributors(bitbucketApiClient, repositories, constants_1.SOOS_BITBUCKET_CLOUD_CONTRIBUTOR_AUDIT_CONSTANTS.RequestBatchSize);
        const scriptVersion = utilities_1.ParamUtilities.getAsString(implementationParams, "scriptVersion");
        const finalContributors = {
            metadata: {
                scriptVersion: scriptVersion,
                days: days,
            },
            organizationName: workspace,
            contributors: contributors,
        };
        return finalContributors;
    }
    static addProviderArgs(argumentParser) {
        argumentParser.add_argument("--workspace", {
            help: "Organization name to use for the audit.",
            default: false,
            required: true,
        });
        argumentParser.add_argument("--secret", {
            help: "Secret to use for api calls, it should be an app password.",
            default: false,
            required: true,
        });
        argumentParser.add_argument("--username", {
            help: "Username for audit.",
            default: false,
            required: true,
        });
    }
    static parseArgs(argumentParser) {
        this.addProviderArgs(argumentParser);
        return argumentParser.parse_args();
    }
    async getBitbucketCloudRepositoryContributors(bitbucketApiClient, repositories, batchSize) {
        const contributorsArray = [];
        for (let i = 0; i < repositories.length; i += batchSize) {
            const batch = repositories.slice(i, i + batchSize);
            const results = await Promise.all(batch.map((repo) => bitbucketApiClient.getBitbucketCloudRepositoryContributors(repo)));
            contributorsArray.push(...results);
        }
        return utilities_1.DataMappingUtilities.mergeContributors(contributorsArray);
    }
}
exports.default = BitbucketCloudContributorAuditProvider;
