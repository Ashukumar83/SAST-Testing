"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const logging_1 = require("../../../../logging");
const utilities_1 = require("../../utilities");
const GitHubApiClient_1 = tslib_1.__importDefault(require("./GitHubApiClient"));
const constants_1 = require("./constants");
class GitHubContributorAuditProvider {
    async audit(implementationParams) {
        const gitHubPAT = utilities_1.ParamUtilities.getAsString(implementationParams, "secret");
        const organizationName = utilities_1.ParamUtilities.getAsString(implementationParams, "organizationName");
        const days = utilities_1.ParamUtilities.getAsNumber(implementationParams, "days");
        const gitHubApiClient = new GitHubApiClient_1.default(days, gitHubPAT, organizationName);
        const organizations = await gitHubApiClient.getGitHubOrganizations();
        logging_1.soosLogger.verboseDebug("Fetching GitHub repositories");
        const repositories = await Promise.all(organizations.map((org) => gitHubApiClient.getGitHubOrganizationRepositories(org)));
        logging_1.soosLogger.verboseDebug("Fetching commits for each repository");
        const contributors = await this.getGitHubRepositoryContributors(gitHubApiClient, repositories.flatMap((repoArray) => {
            return repoArray;
        }), constants_1.SOOS_GITHUB_CONTRIBUTOR_AUDIT_CONSTANTS.RequestBatchSize);
        const scriptVersion = utilities_1.ParamUtilities.getAsString(implementationParams, "scriptVersion");
        const finalContributors = {
            metadata: {
                scriptVersion: scriptVersion,
                days: days,
            },
            organizationName: organizationName,
            contributors: contributors,
        };
        return finalContributors;
    }
    static addProviderArgs(argumentParser) {
        argumentParser.add_argument("--organizationName", {
            help: "Organization name to use for the audit.",
            default: false,
            required: true,
        });
        argumentParser.add_argument("--secret", {
            help: "Secret to use for api calls, it should be a GPAT.",
            default: false,
            required: true,
        });
    }
    static parseArgs(argumentParser) {
        this.addProviderArgs(argumentParser);
        return argumentParser.parse_args();
    }
    async getGitHubRepositoryContributors(gitHubApiClient, repositories, batchSize) {
        const contributorsArray = [];
        for (let i = 0; i < repositories.length; i += batchSize) {
            const batch = repositories.slice(i, i + batchSize);
            const results = await Promise.all(batch.map((repo) => gitHubApiClient.getGitHubRepositoryContributors(repo)));
            contributorsArray.push(...results);
        }
        return utilities_1.DataMappingUtilities.mergeContributors(contributorsArray);
    }
}
exports.default = GitHubContributorAuditProvider;
