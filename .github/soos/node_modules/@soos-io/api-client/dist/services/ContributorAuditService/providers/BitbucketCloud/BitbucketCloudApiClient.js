"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const SOOSLogger_1 = require("../../../../logging/SOOSLogger");
const utilities_1 = require("../../../../utilities");
const constants_1 = require("./constants");
const utilities_2 = require("../../utilities");
class BitbucketCloudApiClient {
    constructor(days, username, password, workspace, baseUri = constants_1.SOOS_BITBUCKET_CLOUD_CONTRIBUTOR_AUDIT_CONSTANTS.Urls.API.Base) {
        this.workspace = workspace;
        this.days = days;
        this.dateToFilter = utilities_1.DateUtilities.getDate(this.days).toISOString();
        this.client = BitbucketCloudApiClient.createHttpClient({
            baseUri,
            username: username,
            password: password,
            apiClientName: "BitbucketCloud API",
            dateToFilter: this.dateToFilter,
        });
    }
    static createHttpClient({ baseUri, username, password }) {
        const client = axios_1.default.create({
            baseURL: baseUri,
            auth: {
                username: username,
                password: password,
            },
        });
        return client;
    }
    async getBitbucketCloudRepositories() {
        this.client.interceptors.response.use((response) => {
            if (response.data.next) {
                return BitbucketCloudApiClient.handleRepositoryPagination(response, this.client, this.dateToFilter);
            }
            return response;
        });
        const response = await this.client.get(`repositories/${this.workspace}`);
        const repoResponse = response.data;
        const repos = repoResponse.values.filter((repo) => utilities_1.DateUtilities.isWithinDateRange(new Date(repo.updated_on), new Date(this.dateToFilter)));
        return repos;
    }
    async getBitbucketCloudRepositoryContributors(repository) {
        await this.setupInterceptor(this.client, "BitbucketCloud API", this.dateToFilter, this.handleCommitPagination);
        const response = await this.client.get(`repositories/${this.workspace}/${repository.name}/commits`);
        response.data.values = response.data.values.filter((commit) => utilities_1.DateUtilities.isWithinDateRange(new Date(commit.date), new Date(this.dateToFilter)));
        const commits = response.data;
        const contributors = commits.values.reduce((acc, commit) => {
            const username = commit.author.user ? commit.author.user.display_name : "Unknown Author";
            const commitDate = commit.date;
            const repo = {
                id: repository.uuid,
                name: repository.name,
                lastCommit: commitDate,
                isPrivate: repository.is_private,
            };
            return utilities_2.DataMappingUtilities.updateContributors(acc, repo, username, commitDate);
        }, []);
        return contributors;
    }
    async setupInterceptor(client, apiClientName, dateToFilter, paginationFunction) {
        client.interceptors.response.clear();
        client.interceptors.response.use(async (response) => {
            SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Response Body: ${JSON.stringify(response.data)}`);
            if (response.data.next) {
                return await paginationFunction(response, client, dateToFilter);
            }
            return response;
        }, async (error) => {
            const { config, response } = error;
            const maxRetries = 3;
            config.retryCount = config.retryCount || 0;
            if (response?.status === 429 && config.retryCount < maxRetries) {
                SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Rate limit exceeded on the BitbucketCloud API. Waiting ${constants_1.SOOS_BITBUCKET_CLOUD_CONTRIBUTOR_AUDIT_CONSTANTS.RetrySeconds} seconds before retrying. Retry count: ${config.retryCount}`);
                config.retryCount += 1;
                await (0, utilities_1.sleep)(constants_1.SOOS_BITBUCKET_CLOUD_CONTRIBUTOR_AUDIT_CONSTANTS.RetrySeconds * 1000);
                return client(config);
            }
            if (response?.status) {
                SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Response Status: ${response.status}`);
            }
            return Promise.reject(error);
        });
    }
    static async handleRepositoryPagination(response, client, dateToFilter) {
        let data = response.data;
        let nextUrl = data.next;
        let isWithinDateRange = data.values.every((repo) => utilities_1.DateUtilities.isWithinDateRange(new Date(repo.updated_on), new Date(dateToFilter)));
        while (nextUrl && isWithinDateRange) {
            SOOSLogger_1.soosLogger.verboseDebug("Fetching next page", nextUrl);
            const nextPageResponse = await client.get(nextUrl);
            data.values = data.values.concat(nextPageResponse.data.values);
            nextUrl = nextPageResponse.data.next ?? undefined;
            isWithinDateRange = nextPageResponse.data.values.every((repo) => utilities_1.DateUtilities.isWithinDateRange(new Date(repo.updated_on), new Date(dateToFilter)));
        }
        return { ...response, data };
    }
    async handleCommitPagination(response, client, dateToFilter) {
        let data = response.data;
        let nextUrl = data.next;
        let lastCommitDate = new Date(data.values[data.values.length - 1].date);
        let isWithinDateRange = utilities_1.DateUtilities.isWithinDateRange(lastCommitDate, new Date(dateToFilter));
        while (nextUrl && isWithinDateRange) {
            SOOSLogger_1.soosLogger.verboseDebug("Fetching next page", nextUrl);
            const nextPageResponse = await client.get(nextUrl);
            data.values = data.values.concat(nextPageResponse.data.values);
            SOOSLogger_1.soosLogger.verboseDebug(`Checking if commits are within date range min date ${new Date(dateToFilter)}`);
            lastCommitDate = new Date(nextPageResponse.data.values[nextPageResponse.data.values.length - 1].date);
            isWithinDateRange = utilities_1.DateUtilities.isWithinDateRange(lastCommitDate, new Date(dateToFilter));
            nextUrl = nextPageResponse.data.next ?? undefined;
        }
        return { ...response, data };
    }
}
exports.default = BitbucketCloudApiClient;
