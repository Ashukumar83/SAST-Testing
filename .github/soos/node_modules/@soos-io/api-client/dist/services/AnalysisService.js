"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratedScanTypes = void 0;
const tslib_1 = require("tslib");
const SOOSAnalysisApiClient_1 = tslib_1.__importDefault(require("../api/SOOSAnalysisApiClient"));
const SOOSProjectsApiClient_1 = tslib_1.__importDefault(require("../api/SOOSProjectsApiClient"));
const SOOSUserApiClient_1 = tslib_1.__importDefault(require("../api/SOOSUserApiClient"));
const constants_1 = require("../constants");
const enums_1 = require("../enums");
const logging_1 = require("../logging");
const utilities_1 = require("../utilities");
const FileSystem = tslib_1.__importStar(require("fs"));
const Path = tslib_1.__importStar(require("path"));
const form_data_1 = tslib_1.__importDefault(require("form-data"));
const Glob = tslib_1.__importStar(require("glob"));
const SOOSHooksApiClient_1 = tslib_1.__importDefault(require("../api/SOOSHooksApiClient"));
const integrationNameToEnvVariable = {
    [enums_1.IntegrationName.AzureDevOps]: "Build.RequestedFor",
    [enums_1.IntegrationName.AWSCodeBuild]: "CODEBUILD_BUILD_INITIATOR",
    [enums_1.IntegrationName.Bamboo]: "bamboo_planRepository_1_username",
    [enums_1.IntegrationName.BitBucket]: "BITBUCKET_STEP_TRIGGERER_UUID",
    [enums_1.IntegrationName.CircleCI]: "CIRCLE_USERNAME",
    [enums_1.IntegrationName.CodeShip]: "CI_COMMITTER_USERNAME",
    [enums_1.IntegrationName.GithubActions]: "GITHUB_ACTOR",
    [enums_1.IntegrationName.GitLab]: "GITLAB_USER_LOGIN",
    [enums_1.IntegrationName.Jenkins]: "CHANGE_AUTHOR",
    [enums_1.IntegrationName.SoosCsa]: "SOOS_CONTRIBUTING_DEVELOPER",
    [enums_1.IntegrationName.SoosDast]: "SOOS_CONTRIBUTING_DEVELOPER",
    [enums_1.IntegrationName.SoosSast]: "SOOS_CONTRIBUTING_DEVELOPER",
    [enums_1.IntegrationName.SoosSca]: "SOOS_CONTRIBUTING_DEVELOPER",
    [enums_1.IntegrationName.SoosSbom]: "SOOS_CONTRIBUTING_DEVELOPER",
    [enums_1.IntegrationName.TeamCity]: "TEAMCITY_BUILD_TRIGGEREDBY_USERNAME",
    [enums_1.IntegrationName.TravisCI]: "TRAVIS_COMMIT",
    [enums_1.IntegrationName.VisualStudio]: "SOOS_CONTRIBUTING_DEVELOPER",
    [enums_1.IntegrationName.VisualStudioCode]: "SOOS_CONTRIBUTING_DEVELOPER",
};
const GeneratedScanTypes = [enums_1.ScanType.CSA, enums_1.ScanType.SBOM, enums_1.ScanType.SCA];
exports.GeneratedScanTypes = GeneratedScanTypes;
class AnalysisService {
    constructor(analysisApiClient, projectsApiClient, userApiClient, hooksApiClient) {
        this.analysisApiClient = analysisApiClient;
        this.projectsApiClient = projectsApiClient;
        this.userApiClient = userApiClient;
        this.hooksApiClient = hooksApiClient;
    }
    static create(apiKey, apiURL) {
        const analysisApiClient = new SOOSAnalysisApiClient_1.default(apiKey, apiURL);
        const projectsApiClient = new SOOSProjectsApiClient_1.default(apiKey, apiURL.replace("api.", "api-projects."));
        const userApiClient = new SOOSUserApiClient_1.default(apiKey, apiURL.replace("api.", "api-user."));
        const hooksApiClient = new SOOSHooksApiClient_1.default(apiKey, apiURL.replace("api.", "api-hooks."));
        return new AnalysisService(analysisApiClient, projectsApiClient, userApiClient, hooksApiClient);
    }
    logStatusMessage(message) {
        if (message) {
            switch (message.severity) {
                case enums_1.SeverityEnum.Unknown:
                case enums_1.SeverityEnum.None:
                case enums_1.SeverityEnum.Info:
                case enums_1.SeverityEnum.Low:
                    logging_1.soosLogger.info(message.message);
                    break;
                case enums_1.SeverityEnum.Medium:
                case enums_1.SeverityEnum.High:
                    logging_1.soosLogger.warn(message.message);
                    break;
                case enums_1.SeverityEnum.Critical:
                    logging_1.soosLogger.error(message.message);
                    break;
            }
            if (message.url) {
                const linkText = message.linkText ? `[${message.linkText}]` : "";
                logging_1.soosLogger.info(`${linkText}(${message.url})`);
            }
        }
    }
    async setupScan({ clientId, projectName, branchName, commitHash, buildVersion, buildUri, branchUri, integrationType, operatingEnvironment, integrationName, appVersion, scriptVersion, contributingDeveloperAudit, scanType, toolName, toolVersion, }) {
        logging_1.soosLogger.info("Checking status...");
        const applicationStatus = await this.userApiClient.getApplicationStatus(clientId);
        this.logStatusMessage(applicationStatus.statusMessage);
        this.logStatusMessage(applicationStatus.clientMessage);
        logging_1.soosLogger.logLineSeparator();
        logging_1.soosLogger.info(`Starting SOOS ${scanType} Analysis`);
        logging_1.soosLogger.info(`Creating scan for project '${projectName}'...`);
        logging_1.soosLogger.info(`Branch Name: ${branchName}`);
        if (contributingDeveloperAudit?.length === 0) {
            logging_1.soosLogger.info(`Integration Name: ${integrationName}`);
            const envVariableName = integrationNameToEnvVariable[integrationName];
            if (envVariableName) {
                const contributingDeveloper = process.env[envVariableName];
                if (contributingDeveloper) {
                    contributingDeveloperAudit.push({
                        source: enums_1.ContributingDeveloperSource.EnvironmentVariable,
                        sourceName: envVariableName,
                        contributingDeveloperId: contributingDeveloper,
                    });
                }
            }
        }
        const result = await this.analysisApiClient.createScan({
            clientId: clientId,
            projectName: projectName,
            commitHash: commitHash,
            branch: branchName,
            buildVersion: buildVersion,
            buildUri: buildUri,
            branchUri: branchUri,
            integrationType: integrationType,
            operatingEnvironment: operatingEnvironment,
            integrationName: integrationName,
            appVersion: appVersion,
            scriptVersion: scriptVersion,
            contributingDeveloperAudit: contributingDeveloperAudit,
            scanType: scanType,
            toolName: toolName,
            toolVersion: toolVersion,
        });
        logging_1.soosLogger.info(`Project Hash: ${result.projectHash}`);
        logging_1.soosLogger.info(`Branch Hash: ${result.branchHash}`);
        logging_1.soosLogger.info(`Scan Id: ${result.analysisId}`);
        logging_1.soosLogger.info("Scan created successfully.");
        return result;
    }
    async startScan({ clientId, projectHash, analysisId, scanType, scanUrl, }) {
        logging_1.soosLogger.info(`Starting ${scanType} Analysis scan`);
        await this.analysisApiClient.startScan({
            clientId: clientId,
            projectHash: projectHash,
            analysisId: analysisId,
        });
        logging_1.soosLogger.info(`Analysis scan started successfully, to see the results visit: ${scanUrl}`);
    }
    async waitForScanToFinish({ scanStatusUrl, scanUrl, scanType, isFirstCheckComplete = false, }) {
        const scanStatus = await this.analysisApiClient.getScanStatus({
            scanStatusUrl: scanStatusUrl,
        });
        if (!scanStatus.isComplete) {
            logging_1.soosLogger.info(`${utilities_1.StringUtilities.fromCamelToTitleCase(scanStatus.status)}...`);
            await (0, utilities_1.sleep)(constants_1.SOOS_CONSTANTS.Status.DelayTime);
            return await this.waitForScanToFinish({ scanStatusUrl, scanUrl, scanType });
        }
        if (!isFirstCheckComplete) {
            await (0, utilities_1.sleep)(constants_1.SOOS_CONSTANTS.Status.DelayTime);
            return await this.waitForScanToFinish({
                scanStatusUrl,
                scanUrl,
                scanType,
                isFirstCheckComplete: true,
            });
        }
        if (scanStatus.errors.length > 0) {
            logging_1.soosLogger.group("Errors:");
            logging_1.soosLogger.warn(JSON.stringify(scanStatus.errors, null, 2));
            logging_1.soosLogger.groupEnd();
        }
        const isGeneratedScanType = GeneratedScanTypes.includes(scanType);
        const vulnerabilities = isGeneratedScanType
            ? `(${utilities_1.StringUtilities.pluralizeTemplate(scanStatus.issues?.Vulnerability?.count ?? 0, "vulnerability", "vulnerabilities")}) `
            : "";
        const codeIssues = scanType === enums_1.ScanType.SAST
            ? `(${utilities_1.StringUtilities.pluralizeTemplate(scanStatus.issues?.Sast?.count ?? 0, "code issue")}) `
            : "";
        const webVulnerabilities = scanType === enums_1.ScanType.DAST
            ? `(${utilities_1.StringUtilities.pluralizeTemplate(scanStatus.issues?.Dast?.count ?? 0, "web vulnerability", "web vulnerabilities")}) `
            : "";
        const violations = isGeneratedScanType
            ? `(${utilities_1.StringUtilities.pluralizeTemplate(scanStatus.issues?.Violation?.count ?? 0, "violation")}) `
            : "";
        const substitutions = isGeneratedScanType
            ? `(${utilities_1.StringUtilities.pluralizeTemplate(scanStatus.issues?.DependencySubstitution?.count ?? 0, "dependency substitution")}) `
            : "";
        const typos = isGeneratedScanType
            ? `(${utilities_1.StringUtilities.pluralizeTemplate(scanStatus.issues?.DependencyTypo?.count ?? 0, "dependency typo")}) `
            : "";
        const unknownPackages = isGeneratedScanType
            ? `(${utilities_1.StringUtilities.pluralizeTemplate(scanStatus.issues?.UnknownPackage?.count ?? 0, "unknown package")}) `
            : "";
        logging_1.soosLogger.always(`Scan ${scanStatus.isSuccess ? "passed" : "failed"}${scanStatus.isSuccess ? ", with" : " because of"} ${vulnerabilities}${codeIssues}${webVulnerabilities}${violations}${substitutions}${typos}${unknownPackages}`);
        logging_1.soosLogger.info(`View the results here: ${scanUrl}`);
        return scanStatus.status;
    }
    async generateFormattedOutput({ clientId, projectHash, projectName, branchHash, scanType, analysisId, outputFormat, workingDirectory, }) {
        logging_1.soosLogger.info(`Generating ${outputFormat} report ${projectName}...`);
        const output = await this.analysisApiClient.getFormattedScanResult({
            clientId: clientId,
            projectHash: projectHash,
            branchHash: branchHash,
            scanType: scanType,
            scanId: analysisId,
            outputFormat: outputFormat,
        });
        if (output) {
            logging_1.soosLogger.info(`${outputFormat} report generated successfully.`);
            logging_1.soosLogger.info(`Output ('${outputFormat}' format):`);
            logging_1.soosLogger.info(JSON.stringify(output, null, 2));
            if (workingDirectory) {
                logging_1.soosLogger.info(`Writing ${outputFormat} report to ${Path.join(workingDirectory, constants_1.SOOS_CONSTANTS.Files.SarifOutput)}`);
                FileSystem.writeFileSync(Path.join(workingDirectory, constants_1.SOOS_CONSTANTS.Files.SarifOutput), JSON.stringify(output, null, 2));
            }
        }
    }
    async updateScanStatus({ clientId, projectHash, branchHash, scanType, analysisId, status, message, scanStatusUrl, }) {
        if (!(0, utilities_1.isNil)(scanStatusUrl)) {
            const scanStatus = await this.analysisApiClient.getScanStatus({
                scanStatusUrl: scanStatusUrl,
            });
            if (scanStatus.isComplete)
                return;
        }
        await this.analysisApiClient.updateScanStatus({
            clientId: clientId,
            projectHash: projectHash,
            branchHash: branchHash,
            scanType: scanType,
            scanId: analysisId,
            status: status,
            message: message,
        });
        if (status === enums_1.ScanStatus.Incomplete || status === enums_1.ScanStatus.Error)
            logging_1.soosLogger.error(message);
    }
    async findAnalysisFiles(scanType, path, pattern, filesToExclude = null, directoriesToExclude = null, maxFiles = 0) {
        process.chdir(path);
        logging_1.soosLogger.info(`Searching for ${scanType} files from ${path}...`);
        const files = Glob.sync(pattern, {
            ignore: [
                ...(filesToExclude || []),
                ...(directoriesToExclude || []),
                constants_1.SOOS_CONSTANTS.Files.SoosDirectoryExclusionGlobPattern,
            ],
            nocase: true,
        });
        const matchingFiles = files.map((x) => Path.resolve(x));
        logging_1.soosLogger.info(`${matchingFiles.length} files found matching pattern '${pattern}'.`);
        matchingFiles.flat().map((filePath) => {
            const filename = Path.basename(filePath);
            const fileStats = FileSystem.statSync(filePath);
            const fileSize = (0, utilities_1.formatBytes)(fileStats.size);
            logging_1.soosLogger.info(`Found ${scanType} file '${filename}' (${fileSize}) at location '${filePath}'.`);
        });
        if (maxFiles < 1) {
            return { filePaths: matchingFiles, hasMoreThanMaximumFiles: false };
        }
        const hasMoreThanMaximumFiles = matchingFiles.length > maxFiles;
        const filesToUpload = matchingFiles.slice(0, maxFiles);
        if (hasMoreThanMaximumFiles) {
            const filesToSkip = matchingFiles.slice(maxFiles);
            const filesDetectedString = utilities_1.StringUtilities.pluralizeTemplate(matchingFiles.length, "file was", "files were");
            const filesSkippedString = utilities_1.StringUtilities.pluralizeTemplate(filesToSkip.length, "file");
            logging_1.soosLogger.info(`The maximum number of ${scanType} files per scan is ${maxFiles}. ${filesDetectedString} detected, and ${filesSkippedString} will be not be uploaded. \n`, `The following files will not be included in the scan: \n`, filesToSkip.map((file) => `  "${Path.basename(file)}": "${file}"`).join("\n"));
        }
        return { filePaths: filesToUpload, hasMoreThanMaximumFiles };
    }
    async findManifestFiles({ clientId, projectHash, branchHash, scanType, analysisId, scanStatusUrl, filesToExclude, directoriesToExclude, sourceCodePath, packageManagers, }) {
        const supportedManifestsResponse = await this.analysisApiClient.getSupportedManifests({
            clientId: clientId,
        });
        const filteredPackageManagers = (0, utilities_1.isNil)(packageManagers) || packageManagers.length === 0
            ? supportedManifestsResponse
            : supportedManifestsResponse.filter((packageManagerManifests) => packageManagers.some((pm) => utilities_1.StringUtilities.areEqual(pm, packageManagerManifests.packageManager, {
                sensitivity: "base",
            })));
        const settings = await this.projectsApiClient.getProjectSettings({
            clientId: clientId,
            projectHash,
        });
        const manifestFiles = this.searchForManifestFiles({
            clientId,
            projectHash,
            branchHash,
            scanType,
            analysisId,
            scanStatusUrl,
            packageManagerManifests: filteredPackageManagers,
            useLockFile: settings.useLockFile ?? false,
            filesToExclude,
            directoriesToExclude,
            sourceCodePath,
        });
        return manifestFiles;
    }
    async searchForManifestFiles({ clientId, projectHash, branchHash, scanType, analysisId, scanStatusUrl, packageManagerManifests, useLockFile, filesToExclude, directoriesToExclude, sourceCodePath, }) {
        const currentDirectory = process.cwd();
        logging_1.soosLogger.info(`Setting current working directory to project path '${sourceCodePath}'.`);
        process.chdir(sourceCodePath);
        logging_1.soosLogger.info(`Lock file setting is ${useLockFile ? "on, ignoring non-lock files" : "off, ignoring lock files"}.`);
        const manifestFiles = packageManagerManifests.reduce((accumulator, packageManagerManifests) => {
            const matches = packageManagerManifests.manifests
                .filter((manifest) => useLockFile === manifest.isLockFile)
                .map((manifest) => {
                const manifestGlobPattern = manifest.pattern.startsWith(".")
                    ? `*${manifest.pattern}`
                    : manifest.pattern;
                const pattern = `**/${manifestGlobPattern}`;
                const files = Glob.sync(pattern, {
                    ignore: [
                        ...(filesToExclude || []),
                        ...directoriesToExclude,
                        constants_1.SOOS_CONSTANTS.SCA.SoosPackageDirToExclude,
                    ],
                    nocase: true,
                });
                const absolutePathFiles = files.map((x) => Path.resolve(x));
                const matchingFilesMessage = `${absolutePathFiles.length} files found matching pattern '${pattern}'.`;
                if (absolutePathFiles.length > 0) {
                    logging_1.soosLogger.info(matchingFilesMessage);
                }
                else {
                    logging_1.soosLogger.verboseInfo(matchingFilesMessage);
                }
                return absolutePathFiles;
            });
            return accumulator.concat(matches.flat().map((filePath) => {
                const filename = Path.basename(filePath);
                const fileStats = FileSystem.statSync(filePath);
                const fileSize = (0, utilities_1.formatBytes)(fileStats.size);
                logging_1.soosLogger.info(`Found manifest file '${filename}' (${fileSize}) at location '${filePath}'.`);
                return {
                    packageManager: packageManagerManifests.packageManager,
                    name: filename,
                    path: filePath,
                };
            }));
        }, []);
        process.chdir(currentDirectory);
        logging_1.soosLogger.info(`Setting current working directory back to '${currentDirectory}'.\n`);
        logging_1.soosLogger.info(`${manifestFiles.length} manifest files found.`);
        if (manifestFiles.length === 0) {
            const errorMessage = "No valid manifests found, cannot continue. For more help, please visit https://kb.soos.io/help/error-no-valid-manifests-found";
            await this.updateScanStatus({
                clientId: clientId,
                projectHash,
                branchHash,
                scanType,
                analysisId: analysisId,
                status: enums_1.ScanStatus.Incomplete,
                message: errorMessage,
                scanStatusUrl,
            });
            throw new Error(errorMessage);
        }
        return manifestFiles;
    }
    async getAnalysisFilesAsFormData(analysisFilePaths, workingDirectory) {
        const analysisFiles = analysisFilePaths.map((filePath) => {
            return {
                name: Path.basename(filePath),
                path: filePath,
            };
        });
        const formData = analysisFiles.reduce((formDataAcc, analysisFile, index) => {
            const fileParts = analysisFile.path.replace(workingDirectory, "").split(Path.sep);
            const parentFolder = fileParts.length >= 2 ? fileParts.slice(0, fileParts.length - 1).join(Path.sep) : "";
            const suffix = index > 0 ? index : "";
            const fileReadStream = FileSystem.createReadStream(analysisFile.path, {
                encoding: constants_1.SOOS_CONSTANTS.FileUploads.Encoding,
            });
            formDataAcc.append(`file${suffix}`, fileReadStream);
            formDataAcc.append(`parentFolder${suffix}`, parentFolder);
            return formDataAcc;
        }, new form_data_1.default());
        return formData;
    }
    async addManifestFilesToScan({ clientId, projectHash, branchHash, analysisId, scanType, scanStatusUrl, manifestFiles, }) {
        const filesToUpload = manifestFiles.slice(0, constants_1.SOOS_CONSTANTS.FileUploads.MaxManifests);
        const hasMoreThanMaximumManifests = manifestFiles.length > constants_1.SOOS_CONSTANTS.FileUploads.MaxManifests;
        if (hasMoreThanMaximumManifests) {
            const filesToSkip = manifestFiles.slice(constants_1.SOOS_CONSTANTS.FileUploads.MaxManifests);
            const filesDetectedString = utilities_1.StringUtilities.pluralizeTemplate(manifestFiles.length, "file was", "files were");
            const filesSkippedString = utilities_1.StringUtilities.pluralizeTemplate(filesToSkip.length, "file");
            logging_1.soosLogger.info(`The maximum number of manifest per scan is ${constants_1.SOOS_CONSTANTS.FileUploads.MaxManifests}. ${filesDetectedString} detected, and ${filesSkippedString} will be not be uploaded. \n`, `The following manifests will not be included in the scan: \n`, filesToSkip.map((file) => `  "${file.name}": "${file.path}"`).join("\n"));
        }
        const manifestsByPackageManager = filesToUpload.reduce((accumulator, file) => {
            const packageManagerFiles = accumulator[file.packageManager] ?? [];
            return {
                ...accumulator,
                [file.packageManager]: packageManagerFiles.concat(file),
            };
        }, {});
        let allUploadsFailed = true;
        for (const [packageManager, files] of Object.entries(manifestsByPackageManager)) {
            try {
                const manifestUploadResponse = await this.uploadManifestFiles({
                    clientId: clientId,
                    projectHash,
                    branchHash,
                    analysisId,
                    manifestFiles: files.map((f) => f.path),
                    hasMoreThanMaximumManifests,
                });
                logging_1.soosLogger.info(`${packageManager} Manifest Files: \n`, `  ${manifestUploadResponse.message} \n`, manifestUploadResponse.manifests
                    ?.map((m) => `  ${m.name}: ${m.statusMessage}`)
                    .join("\n"));
                allUploadsFailed = false;
            }
            catch (e) {
                logging_1.soosLogger.warn(e instanceof Error ? e.message : e);
            }
        }
        if (allUploadsFailed) {
            await this.updateScanStatus({
                clientId,
                projectHash,
                branchHash,
                scanType,
                analysisId: analysisId,
                status: enums_1.ScanStatus.Incomplete,
                message: `Error uploading manifests.`,
                scanStatusUrl,
            });
            throw new Error("Error uploading manifests.");
        }
    }
    async uploadManifestFiles({ clientId, projectHash, branchHash, analysisId, manifestFiles, hasMoreThanMaximumManifests, }) {
        const formData = await this.getAnalysisFilesAsFormData(manifestFiles, process.cwd());
        const response = await this.analysisApiClient.uploadManifestFiles({
            clientId,
            projectHash,
            branchHash,
            analysisId,
            manifestFiles: formData,
            hasMoreThanMaximumManifests,
        });
        return response;
    }
}
exports.default = AnalysisService;
