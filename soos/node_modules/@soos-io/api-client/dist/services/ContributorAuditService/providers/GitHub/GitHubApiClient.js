"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const SOOSLogger_1 = require("../../../../logging/SOOSLogger");
const utilities_1 = require("../../../../utilities");
const constants_1 = require("./constants");
const utilities_2 = require("../../utilities");
class GitHubApiClient {
    constructor(days, gitHubPAT, organizationName, baseUri = constants_1.SOOS_GITHUB_CONTRIBUTOR_AUDIT_CONSTANTS.Urls.API.Base) {
        this.client = GitHubApiClient.createHttpClient({
            baseUri,
            gitHubPAT: gitHubPAT,
            apiClientName: "GitHub API",
        });
        this.organizationName = organizationName;
        this.days = days;
        this.dateToFilter = utilities_1.DateUtilities.getDate(this.days).toISOString();
    }
    static createHttpClient({ baseUri, gitHubPAT: gitHubPAT, apiClientName, }) {
        const client = axios_1.default.create({
            baseURL: baseUri,
            headers: {
                accept: "application/vnd.github+json",
                Authorization: `Bearer ${gitHubPAT}`,
            },
        });
        client.interceptors.request.use((request) => {
            if (request.data) {
                SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Request URL: ${request.method?.toLocaleUpperCase()} ${request.url}`);
                if (request.params) {
                    SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Request Params: ${JSON.stringify(request.params)}`);
                }
                SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Request Body: ${JSON.stringify(request.data)}`);
            }
            return request;
        }, (rejectedRequest) => {
            return Promise.reject(rejectedRequest);
        });
        client.interceptors.response.use(async (response) => {
            SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Response Body: ${JSON.stringify(response.data)}`);
            if (response.config.url?.includes("per_page")) {
                return await GitHubApiClient.handleNextPage(response, client);
            }
            return response;
        }, async (error) => {
            const { config, response } = error;
            const maxRetries = 3;
            config.retryCount = config.retryCount || 0;
            if ((response?.status === 429 || response?.status === 403) &&
                config.retryCount < maxRetries) {
                const rateLimitReset = response?.headers["x-ratelimit-reset"];
                if (rateLimitReset) {
                    SOOSLogger_1.soosLogger.verboseDebug(`Trying to parse rate limit reset: ${rateLimitReset}`);
                    const rateLimitDate = utilities_1.DateUtilities.getDateFromUnixUTC(rateLimitReset);
                    const timeToWait = Math.floor((rateLimitDate.getTime() - Date.now()) / 1000);
                    SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Rate limit exceeded on the GitHub API. Waiting ${timeToWait} seconds before retrying. Retry count: ${config.retryCount}`);
                    config.retryCount += 1;
                    await (0, utilities_1.sleep)(timeToWait * 1000);
                }
                return client(config);
            }
            if (response?.status) {
                SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Response Status: ${response.status}`);
            }
            if (response?.data?.message) {
                SOOSLogger_1.soosLogger.verboseDebug(apiClientName, `Response Message: ${response.data.message}`);
            }
            return Promise.reject(error);
        });
        return client;
    }
    static async handleNextPage(response, client) {
        let data = response.data;
        let nextUrl = GitHubApiClient.getNextPageUrl(response);
        if (nextUrl) {
            SOOSLogger_1.soosLogger.verboseDebug("Fetching next page", nextUrl);
            const nextPageResponse = await client.get(nextUrl);
            data = data.concat(nextPageResponse.data);
        }
        return { ...response, data };
    }
    static getNextPageUrl(response) {
        const linkHeader = response.headers["link"];
        const nextLink = linkHeader?.split(",").find((s) => s.includes('rel="next"'));
        return nextLink
            ? new URL(nextLink.split(";")[0].trim().slice(1, -1), response.config.baseURL).toString()
            : null;
    }
    async getGitHubOrganizations() {
        const response = await this.client.get(`user/orgs?per_page=100`);
        const orgs = response.data.filter((org) => org.login.toLowerCase() === this.organizationName.toLowerCase());
        if (orgs.length === 0) {
            throw new Error(`Organization ${this.organizationName} not found`);
        }
        return orgs;
    }
    async getGitHubOrganizationRepositories(organization) {
        const response = await this.client.get(`orgs/${organization.login}/repos?per_page=50`);
        const repos = response.data.filter((repo) => utilities_1.DateUtilities.isWithinDateRange(new Date(repo.pushed_at), new Date(this.dateToFilter)));
        return repos;
    }
    async getGitHubRepositoryContributors(repository) {
        const response = await this.client.get(`repos/${repository.owner.login}/${repository.name}/commits?per_page=100&since=${this.dateToFilter}`);
        const commits = await response.data;
        const contributors = commits.reduce((acc, commit) => {
            const username = commit.commit.author.name;
            const commitDate = commit.commit.author.date;
            const repo = {
                id: repository.id.toString(),
                name: repository.name,
                lastCommit: commitDate,
                isPrivate: repository.private,
            };
            return utilities_2.DataMappingUtilities.updateContributors(acc, repo, username, commitDate);
        }, []);
        return contributors;
    }
}
exports.default = GitHubApiClient;
