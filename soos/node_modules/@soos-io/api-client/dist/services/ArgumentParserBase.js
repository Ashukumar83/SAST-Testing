"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArgumentParserBase = void 0;
const enums_1 = require("../enums");
const constants_1 = require("../constants");
const enums_2 = require("../enums");
const utilities_1 = require("../utilities");
const getIntegrateUrl = (scanType) => `${constants_1.SOOS_CONSTANTS.Urls.App.Home}integrate/${scanType == enums_2.ScanType.CSA ? "containers" : (scanType ?? enums_2.ScanType.SCA).toLowerCase()}`;
class ArgumentParserBase {
    constructor(argumentParser, scanType, scriptVersion, integrationName, integrationType) {
        this.scriptVersion = "0.0.0";
        this.argumentParser = argumentParser;
        this.scanType = scanType;
        this.scriptVersion = scriptVersion ?? "0.0.0";
        this.integrationName = integrationName;
        this.integrationType = integrationType;
    }
    addCommonArguments(scriptVersion, integrationName, integrationType) {
        this.argumentParser.add_argument("--apiKey", {
            help: `SOOS API Key - get yours from ${getIntegrateUrl(this.scanType)}`,
            default: (0, utilities_1.getEnvVariable)(constants_1.SOOS_CONSTANTS.EnvironmentVariables.ApiKey),
            required: false,
        });
        this.argumentParser.add_argument("--apiURL", {
            help: "SOOS API URL - Intended for internal use only, do not modify.",
            default: constants_1.SOOS_CONSTANTS.Urls.API.Analysis,
            required: false,
            type: (value) => {
                return (0, utilities_1.ensureNonEmptyValue)(value, "apiURL");
            },
        });
        this.argumentParser.add_argument("--clientId", {
            help: `SOOS Client ID - get yours from ${getIntegrateUrl(this.scanType)}`,
            default: (0, utilities_1.getEnvVariable)(constants_1.SOOS_CONSTANTS.EnvironmentVariables.ClientId),
            required: false,
        });
        this.addEnumArgument(this.argumentParser, "--integrationName", enums_2.IntegrationName, {
            help: "Integration Name - Intended for internal use only.",
            required: false,
            default: integrationName,
        });
        this.addEnumArgument(this.argumentParser, "--integrationType", enums_1.IntegrationType, {
            help: "Integration Type - Intended for internal use only.",
            required: false,
            default: integrationType,
        });
        this.addEnumArgument(this.argumentParser, "--logLevel", enums_2.LogLevel, {
            help: "Minimum level to show logs: PASS, IGNORE, INFO, WARN or FAIL.",
            default: enums_2.LogLevel.INFO,
            required: false,
        });
        this.argumentParser.add_argument("--scriptVersion", {
            help: "Script Version - Intended for internal use only.",
            required: false,
            default: scriptVersion,
        });
        this.argumentParser.add_argument("--verbose", {
            help: "Enable verbose logging.",
            action: "store_true",
            default: false,
            required: false,
        });
    }
    addEnumArgument(parser, argName, enumObject, options = {}, allowMultipleValues = false) {
        parser.add_argument(argName, {
            ...options,
            type: (value) => {
                if (allowMultipleValues) {
                    return value
                        .split(",")
                        .map((v) => v.trim())
                        .filter((v) => v !== "")
                        .map((v) => (0, utilities_1.ensureEnumValue)(enumObject, v, argName));
                }
                return (0, utilities_1.ensureEnumValue)(enumObject, value, argName);
            },
        });
    }
    parseArguments() {
        this.addCommonArguments(this.scriptVersion, this.integrationName, this.integrationType);
        const args = this.argumentParser.parse_args();
        this.ensureRequiredArguments(args);
        return args;
    }
    ensureRequiredArguments(args) {
        (0, utilities_1.ensureNonEmptyValue)(args.clientId, "clientId");
        (0, utilities_1.ensureNonEmptyValue)(args.apiKey, "apiKey");
    }
}
exports.ArgumentParserBase = ArgumentParserBase;
