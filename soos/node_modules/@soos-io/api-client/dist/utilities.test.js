"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const enums_1 = require("./enums");
const utilities_1 = require("./utilities");
describe("isNil", () => {
    test("should return true for null", () => {
        expect((0, utilities_1.isNil)(null)).toBe(true);
    });
    test("should return true for undefined", () => {
        expect((0, utilities_1.isNil)(undefined)).toBe(true);
    });
    test("should return false for a non-nil value", () => {
        expect((0, utilities_1.isNil)("string")).toBe(false);
    });
});
describe("ensureValue", () => {
    test("should throw an error for null", () => {
        expect(() => (0, utilities_1.ensureValue)(null, "property")).toThrow("'property' is required.");
    });
    test("should throw an error for undefined", () => {
        expect(() => (0, utilities_1.ensureValue)(undefined, "property")).toThrow("'property' is required.");
    });
    test("should return the value for a non-nil value", () => {
        expect((0, utilities_1.ensureValue)("value", "property")).toBe("value");
    });
});
describe("ensureNonEmptyValue", () => {
    test("should throw an error for null", () => {
        expect(() => (0, utilities_1.ensureNonEmptyValue)(null, "property")).toThrow("'property' is required.");
    });
    test("should throw an error for undefined", () => {
        expect(() => (0, utilities_1.ensureNonEmptyValue)(undefined, "property")).toThrow("'property' is required.");
    });
    test("should throw an error for an empty string", () => {
        expect(() => (0, utilities_1.ensureNonEmptyValue)("", "property")).toThrow("'property' is required.");
    });
    test("should throw an error for a string with only spaces", () => {
        expect(() => (0, utilities_1.ensureNonEmptyValue)("   ", "property")).toThrow("'property' is required.");
    });
    test("should return the value for a non-empty string", () => {
        expect((0, utilities_1.ensureNonEmptyValue)("value", "property")).toBe("value");
    });
});
describe("ensureEnumValue", () => {
    test("should return undefined for null", () => {
        expect((0, utilities_1.ensureEnumValue)({ value: "value" }, null)).toBe(undefined);
    });
    test("should return undefined for undefined", () => {
        expect((0, utilities_1.ensureEnumValue)({ value: "value" }, undefined)).toBe(undefined);
    });
    test("should throw an error for an invalid enum value", () => {
        expect(() => (0, utilities_1.ensureEnumValue)({ value: "value" }, "invalid")).toThrow("Invalid value 'invalid' for parameter. Valid options are: value.");
    });
    test("should throw an error for an invalid enum value with parameterName", () => {
        expect(() => (0, utilities_1.ensureEnumValue)({ value: "value" }, "invalid", "parameterName")).toThrow("Invalid value 'invalid' for 'parameterName'. Valid options are: value.");
    });
    test("should return the enum value for a valid enum value", () => {
        expect((0, utilities_1.ensureEnumValue)({ value: "value" }, "value")).toBe("value");
    });
    test("should return the enum value for a valid enum value with different case", () => {
        expect((0, utilities_1.ensureEnumValue)({ value: "value" }, "VALUE")).toBe("value");
    });
});
describe("getAnalysisExitCodeWithMessage", () => {
    test("should return 0 on finished with continue", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.Finished, enums_1.IntegrationName.SoosCsa, enums_1.OnFailure.Continue).exitCode).toBe(0);
    });
    test("should return 0 on finished with fail", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.Finished, enums_1.IntegrationName.SoosSca, enums_1.OnFailure.Fail)
            .exitCode).toBe(0);
    });
    test("should return 0 for an Incomplete status with continue", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.Incomplete, enums_1.IntegrationName.SoosSca, enums_1.OnFailure.Continue).exitCode).toBe(0);
    });
    test("should return 1 for an Incomplete status with fail", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.Incomplete, enums_1.IntegrationName.SoosSca, enums_1.OnFailure.Fail)
            .exitCode).toBe(1);
    });
    test("should return 0 for an Error status with continue", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.Error, enums_1.IntegrationName.SoosSca, enums_1.OnFailure.Continue)
            .exitCode).toBe(0);
    });
    test("should return 1 for an Error status with fail", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.Error, enums_1.IntegrationName.SoosSca, enums_1.OnFailure.Fail)
            .exitCode).toBe(1);
    });
    test("should return 0 for a FailedWithIssues status with continue", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.FailedWithIssues, enums_1.IntegrationName.SoosSca, enums_1.OnFailure.Continue).exitCode).toBe(0);
    });
    test("should return 1 for a FailedWithIssues status with fail", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.FailedWithIssues, enums_1.IntegrationName.SoosSca, enums_1.OnFailure.Fail).exitCode).toBe(1);
    });
    test("should return 2 for a FailedWithIssues status with continue when DevOps", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.FailedWithIssues, enums_1.IntegrationName.AzureDevOps, enums_1.OnFailure.Continue).exitCode).toBe(2);
    });
    test("should return 1 for a FailedWithIssues status with fail when DevOps", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.FailedWithIssues, enums_1.IntegrationName.AzureDevOps, enums_1.OnFailure.Fail).exitCode).toBe(1);
    });
    test("should return 2 for an Incomplete status with continue when DevOps", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.Incomplete, enums_1.IntegrationName.AzureDevOps, enums_1.OnFailure.Continue).exitCode).toBe(2);
    });
    test("should return 1 for an Incomplete status with fail when DevOps", () => {
        expect((0, utilities_1.getAnalysisExitCodeWithMessage)(enums_1.ScanStatus.Incomplete, enums_1.IntegrationName.AzureDevOps, enums_1.OnFailure.Fail).exitCode).toBe(1);
    });
});
describe("StringUtilities.pluralizeWord", () => {
    test("pluralizeWord should return the singular word for a count of 1", () => {
        expect(utilities_1.StringUtilities.pluralizeWord(1, "word")).toBe("word");
    });
    test("pluralizeWord should return the plural word for a count of 0", () => {
        expect(utilities_1.StringUtilities.pluralizeWord(0, "word")).toBe("words");
    });
    test("pluralizeWord should return the plural word for a count of null", () => {
        expect(utilities_1.StringUtilities.pluralizeWord(null, "word")).toBe("words");
    });
    test("pluralizeWord should return the plural word for a count of undefined", () => {
        expect(utilities_1.StringUtilities.pluralizeWord(undefined, "word")).toBe("words");
    });
});
describe("StringUtilities.pluralizeTemplate", () => {
    test("pluralizeTemplate should return the singular word for a count of 1", () => {
        expect(utilities_1.StringUtilities.pluralizeTemplate(1, "word")).toBe("1 word");
    });
    test("pluralizeTemplate should return the plural word for a count of 0", () => {
        expect(utilities_1.StringUtilities.pluralizeTemplate(0, "word")).toBe("0 words");
    });
    test("pluralizeTemplate should return the singular word for a count of null", () => {
        expect(utilities_1.StringUtilities.pluralizeTemplate(null, "word")).toBe("0 words");
    });
});
describe("StringUtilities.fromCamelToTitleCase", () => {
    test("fromCamelToTitleCase should return a title case string", () => {
        expect(utilities_1.StringUtilities.fromCamelToTitleCase("camelCase")).toBe("Camel Case");
    });
    test("fromCamelToTitleCase should return a title case string with multiple words", () => {
        expect(utilities_1.StringUtilities.fromCamelToTitleCase("camelCaseString")).toBe("Camel Case String");
    });
});
describe("StringUtilities.areEqual", () => {
    test("areEqual should return true for equal strings", () => {
        expect(utilities_1.StringUtilities.areEqual("string", "string")).toBe(true);
    });
    test("areEqual should return false for unequal strings", () => {
        expect(utilities_1.StringUtilities.areEqual("string", "other")).toBe(false);
    });
    test("areEqual should return false for unequal strings with different cases", () => {
        expect(utilities_1.StringUtilities.areEqual("string", "STRING")).toBe(false);
    });
    test("areEqual should return true for equal strings with different cases when case is ignored", () => {
        expect(utilities_1.StringUtilities.areEqual("string", "STRING", { sensitivity: "base" })).toBe(true);
    });
    describe("StringUtilities.isEmptyString", () => {
        test("should return true for an empty string", () => {
            expect(utilities_1.StringUtilities.isEmptyString("")).toBe(true);
        });
        test("should return true for a string with only spaces", () => {
            expect(utilities_1.StringUtilities.isEmptyString("   ")).toBe(true);
        });
        test("should return false for a non-empty string", () => {
            expect(utilities_1.StringUtilities.isEmptyString("value")).toBe(false);
        });
    });
});
