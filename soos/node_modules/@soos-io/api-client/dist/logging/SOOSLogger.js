"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.soosLogger = void 0;
const enums_1 = require("../enums");
class SOOSLogger {
    constructor(verbose = false, minLogLevel = enums_1.LogLevel.INFO, console = global.console) {
        this.verbose = verbose;
        this.console = console;
        this.minLogLevel = this.verbose ? enums_1.LogLevel.DEBUG : minLogLevel;
    }
    getTimeStamp() {
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, "0");
        const day = now.getDate().toString().padStart(2, "0");
        const hours = (now.getHours() % 12 || 12).toString().padStart(2, "0");
        const ampm = now.getHours() >= 12 ? "PM" : "AM";
        const minutes = now.getMinutes().toString().padStart(2, "0");
        const seconds = now.getSeconds().toString().padStart(2, "0");
        const timestamp = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${ampm}`;
        return `${timestamp}`;
    }
    logWithTimestamp(level, message, ...optionalParams) {
        if (this.shouldLog(level)) {
            const logLevelKey = enums_1.LogLevel[level];
            const timestamp = this.getTimeStamp();
            const logMessage = `${timestamp} UTC [${logLevelKey}] ${message}`;
            this.console.log(logMessage, ...optionalParams);
        }
    }
    shouldLog(level) {
        const orderedKeys = Object.keys(enums_1.LogLevel);
        return orderedKeys.indexOf(level) >= orderedKeys.indexOf(this.minLogLevel);
    }
    setVerbose(verbose) {
        this.verbose = this.minLogLevel === enums_1.LogLevel.DEBUG || verbose;
        if (this.verbose)
            this.minLogLevel = enums_1.LogLevel.DEBUG;
    }
    setMinLogLevel(minLogLevel) {
        this.minLogLevel = minLogLevel;
        if (this.minLogLevel === enums_1.LogLevel.DEBUG)
            this.verbose = true;
    }
    debug(message, ...optionalParams) {
        this.logWithTimestamp(enums_1.LogLevel.DEBUG, message, ...optionalParams);
    }
    info(message, ...optionalParams) {
        this.logWithTimestamp(enums_1.LogLevel.INFO, message, ...optionalParams);
    }
    warn(message, ...optionalParams) {
        this.logWithTimestamp(enums_1.LogLevel.WARN, message, ...optionalParams);
    }
    error(message, ...optionalParams) {
        this.logWithTimestamp(enums_1.LogLevel.ERROR, message, ...optionalParams);
    }
    group(...label) {
        this.console.group(...label);
    }
    groupEnd() {
        this.console.groupEnd();
        this.console.log("\n");
    }
    verboseDebug(message, ...optionalParams) {
        if (this.verbose) {
            this.debug(message, ...optionalParams);
        }
    }
    verboseInfo(message, ...optionalParams) {
        if (this.verbose) {
            this.info(message, ...optionalParams);
        }
    }
    verboseWarn(message, ...optionalParams) {
        if (this.verbose) {
            this.warn(message, ...optionalParams);
        }
    }
    verboseError(message, ...optionalParams) {
        if (this.verbose) {
            this.error(message, ...optionalParams);
        }
    }
    verboseGroup(...label) {
        if (this.verbose) {
            this.group(...label);
        }
    }
    verboseGroupEnd() {
        if (this.verbose) {
            this.groupEnd();
        }
    }
    always(message, ...optionalParams) {
        const timestamp = this.getTimeStamp();
        const logMessage = `${timestamp} UTC [SOOS] ${message}`;
        this.console.log(logMessage, ...optionalParams);
    }
    logLineSeparator() {
        const separator = "-".repeat(80);
        this.console.log(`${separator}\n`);
    }
}
exports.default = SOOSLogger;
exports.soosLogger = new SOOSLogger();
